/*
 * Copyright (c) 2019 Intel Corporation
 * 
 * Tool to help running a process in normal user with supplementary groups
 * and provides ambient caps.
 *
 * alexander.abraham@intel.com
 *
 */

#define  _GNU_SOURCE

#include <stdio.h>
#include <inttypes.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/prctl.h>
#include <sys/types.h>
#include <pwd.h>
#include <errno.h>
#include <linux/securebits.h>
#include <linux/capability.h>
#include <grp.h>

/* Autogenerated header file using make_capabilities_h.sh script */
#include "capabilities-names.h"

/* Get external environmental variables */
extern char **environ;

/* Toolchain may not add capset prototype as it is a direct syscall operation.
 * Better we define ourselves
 */
extern int capset(cap_user_header_t hdrp, const cap_user_data_t datap);

/*
 * Function to Drop all capabilities
 * Uses prctl PR_CAPBSET_DROP calls to drop all capabilites
 * from 0 till CAP_LAST_CAP
 */
__attribute__((unused)) static void caps_drop_all(void)
{
	unsigned long cap;
	int code;

	printf("Droping all capabilities\n");

	for (cap=0; cap <= CAP_LAST_CAP; cap++) {
		code = prctl(PR_CAPBSET_DROP, cap, 0, 0, 0);
		if (code == -1 && errno != EINVAL)
			perror("PR_CAPBSET_DROP");
	}
}

/*
 * Function to read and print all capabilities
 * Uses prctl PR_CAPBSET_READ, calls to read all capabilites
 * from 0 till CAP_LAST_CAP
 */
__attribute__((unused)) static void caps_read_all(void)
{
	unsigned long cap;
	int code;
	printf("Reading all capabilities\n");

	for (cap=0; cap <= CAP_LAST_CAP; cap++) {
		code = prctl(PR_CAPBSET_READ, cap, 0, 0, 0);
		printf("CAP %lu: %s: Value: %d\n", cap, capabilities_names[cap], code);
	}
}

/*
 * Function to keep capabilities as mentioned in 'caps' variable and drops other all.
 * Uses prctl PR_CAPBSET_DROP, to drop non-mentioned capabilities one by one.
 */
static void caps_set(uint64_t caps)
{
	unsigned long i;
	uint64_t mask = 1LLU;
	int code;
	for (i = 0; i <= CAP_LAST_CAP; i++, mask <<= 1) {
		if ((mask & caps) == 0) {
			code = prctl(PR_CAPBSET_DROP, i, 0, 0, 0);
			if (code == -1 && errno != EINVAL)
				perror("PR_CAPBSET_DROP");
		}
	}
}

/*
 * Compare comma separated capability list with a capability name.
 */
static int cap_cmp(const char *d, char *s)
{
	unsigned int flg = 0;
	const char *t = d;

	while (*s != '\0') {
		if ((*s < 'a' || *s > 'z') && *s != '_' && *s != ',') {
			printf("Invalid capability names used! Use capability names in lowercase separated with commas.\n");
			exit(1);
		}
		if (*s == ',') {
			if ((flg == 1) && (*t == '\0'))
				return 1;

			t = d;
			flg = 0;
			s++;
		}

		if (flg != 2) {
			if (*s == *t) {
				flg = 1;
			} else {
				t = d;
				flg = 2;
			}
		}

		t++;
		s++;
	}

	if ((flg == 1) && (*t == '\0'))
		return 1;

	return 0;
}


/*
 * Arguments supported:
 * 1: User name to use. Example: nobody
 * 2: Requested caps. Mention cap names separated with commas. Example: cap_net_raw,cap_net_admin
 * 3: Program path and its arguments. Example: /sbin/ifconfig eth1 up
 *
 * Program example:-
 *      ./cap_provide nobody cap_net_raw,cap_net_admin,cap_net_bind /sbin/ifconfig eth1 up
 *
 */
int main(int argc, char **argv)
{
	int i, j, err, flg=0;
	struct passwd *p = NULL;
	struct __user_cap_header_struct hdr;
	struct __user_cap_data_struct data;
	char *v = NULL, *u = NULL, *g = NULL, *s = NULL, group_override = 0;
	/* We store user requested caps in 'caps' variable */
	uint64_t caps = 0LLU;
	struct group *gr = NULL;
	gid_t glist[NGROUPS_MAX];
	int ngroups = 0;
	uid_t uid = 0;
	gid_t gid = 0;

	char *user = NULL, *u_caps = NULL;

	if (argc < 4) {
		printf("Usage: %s <user>:[group],[group1,group2,groupN] <\"cap1,cap2,cap3..\"> <program>\n", argv[0]);
		exit(1);
	}

	/* Read username from 1st argument */
	user = argv[1];

	/* Read cap names from 2nd argument */
	u_caps = argv[2];

	/* Shift to 3rd argument so that we will have program with its argument list */
	argv+=3;

	printf("Userinput: %s\n", user);

	/* Extract user, group and supplementary groups from user input */
	v = user;
	while (*v != '\0') {
		if (!u && !g && !s && *v == ':') {
			*v = '\0';
			u = user;
			g = (v + 1);
			group_override = 1;
		}
		if (u && g && !s && *v == ',') {
			*v = '\0';
			s = (v + 1);
			break;
		}
		v++;
	}

	if (!u) {
		u = user;
	}

	if (u) {
		if (*u == '\0') {
			uid = getuid();
			p = getpwuid(uid);
		} else {
			p = getpwnam(u);
		}

		if (p != NULL) {
			uid = p->pw_uid;
			u = p->pw_name;
			if (g) {
				gr = getgrnam(g);
				if (gr != NULL) {
					gid = gr->gr_gid;
				} else {
					printf("Invalid group '%s' mentioned!\n", g);
					exit(1);
				}
			} else {
				g = u;
				gid = p->pw_gid;
			}
		} else {
			printf("Invalid user '%s' mentioned!\n", u);
			exit(1);
		}
	}

	if (!u || !g) {
		printf("Invalid user or group mentioned!\n");
		exit(1);
	}

	printf("User: %s UID: %d\n", u, uid);
	printf("Group: %s GID: %d\n", g, gid);

	/* Extract supplementary groups */
	if (s) {
		v = s;
		while (*v != '\0') {
			if (*v == ',') {
				*v = '\0';
				gr = getgrnam(s);
				if (gr != NULL) {
					glist[ngroups++] = gr->gr_gid;
					printf("Supplementary group: %s GID: %d\n", s, gr->gr_gid);
				} else {
					printf("Invalid supplementary group '%s' mentioned!\n", s);
					exit(1);
				}
				s = (v + 1);
			}
			v++;
		}
		gr = getgrnam(s);
		if (gr != NULL) {
			glist[ngroups++] = gr->gr_gid;
			printf("Supplementary group: %s GID: %d\n", s, gr->gr_gid);
		} else {
			printf("Invalid supplementary group '%s' mentioned!\n", s);
			exit(1);
		}
	}

	/* Read cap index from cap list separated by commas. Remove commas and get the list */
	for (j = 0; j <= CAP_LAST_CAP; j++) {
		if (cap_cmp(capabilities_names[j], u_caps) || cap_cmp("cap_all", u_caps)) {
			printf("Caps set: %s, no: %d\n", capabilities_names[j], j);
			caps |= (1LLU << j);
		}
	}

	//printf("Last CAP is: %d: %s\n", CAP_LAST_CAP, capabilities_names[CAP_LAST_CAP]);

	/* Set no_new_privs, so that not to grant privileges to do anything that could not have
	 * been done without the execve
	 */
	prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);

	/* Inherit caps across setuid/setgid operation */
	prctl(PR_SET_KEEPCAPS, 1, 0, 0, 0);

	/* Apply only user requested caps from 'caps' variable to the current process now and drop other all.
	 * Additionally keep CAP_SETPCAP cap without dropping for executing prctl cap operation APIs.
	 * Also keep CAP_SETGID,CAP_SETUID caps for executing setuid, setgid API calls to switch to a requested user.
	 */
	caps_set((1LLU << CAP_SETPCAP) | (1LLU << CAP_SETGID) | (1LLU << CAP_SETUID) | caps); // caps and additional caps to execute our APIs.

	/* Read username and get uid, gid details from user name. */
	/* Initialize supplementary groups found from user. One user may have more that one groups.
	 * So initialize them also. Otherwise, the program called under execve can use only its primary group.
	 */
	if (!group_override) {
		printf("Initializing supplementary groups from /etc/group file..\n");
		if (initgroups(u, gid) != 0) {
			printf("Failed to set supplementary groups from /etc/group file: initgroups() failed!\n");
			exit(1);
		}
	} else {
		printf("Initializing supplementary groups from Input..\n");
		if (ngroups) {
			if (setgroups(ngroups, glist) != 0) {
				printf("Failed to set supplementary groups from the input: setgroups() failed!\n");
				exit(1);
			}
		} else {
			setgroups(0, NULL);
		}
	}

	/* Now switch to user and group id */
	if (setgid(gid)) {
		printf("failed to set group id %d\n", gid);
		exit(127);
	}

	if (setuid(uid)) {
		printf("failed to set user id %d:\n", uid);
		exit(127);
	}

	/* After switching to a normal user, Linux drops all caps by default. But still we can get back with capset API by requesting those
	 * cap names. The PR_SET_KEEPCAPS operation done before helps to do that.
	 */
	/* Fill details to call capset API */
    	hdr.pid = getpid();
    	hdr.version = _LINUX_CAPABILITY_VERSION;
	data.effective = 0LLU;
	data.permitted = 0LLU;
	data.inheritable = 0LLU;

	/* Fill in caps name which we needed to get back. We can assign 'caps' variable directly.
	 *
	 * Also additinally request for CAP_SETPCAP to use cap set operation later with prctl API. Otherwise the API call itself will fail.
	 * Also request for CAP_DAC_OVERRIDE. This cap helps executing a program owner by root. Because once we switch to normal user,
	 * we may not be able to execute a process which is only owned by root. CAP_DAC_OVERRIDE will help in executing that.
	 * But we make sure that we use it only for first execve and not inherit this cap for later use.
	 * So we use this cap only for effective and permitted sets. inheritable set will have only 'caps' variable which we really
	 * need to inherit.
	 */
	data.effective |= (1LLU << CAP_SETPCAP) | (1LLU << CAP_DAC_OVERRIDE) | caps;
	data.permitted |= (1LLU << CAP_SETPCAP) | (1LLU << CAP_DAC_OVERRIDE) | caps;
	data.inheritable |= caps;

	/* Call capset to get all defined caps */
	if(capset(&hdr, &data))
		printf("capset failed: %m\n");

	/* After capset, here we have all requested caps. But still it cannot be used after execve. Ambient caps settings will
	 * actually helps inheriting caps accross execve. Use prctl(PR_CAP_AMBIENT operation to raise all required caps. */
	for (i = 0; i <= CAP_LAST_CAP; i++) {
		if (caps & (1LLU << i)) {
			printf("Ambient raise: %s\n", capabilities_names[i]);
			if ((err = prctl(PR_CAP_AMBIENT, PR_CAP_AMBIENT_RAISE, i, 0, 0)) < 0) {
				perror("Error");
				printf("Failed to apply PR_CAP_AMBIENT_RAISE for %s err: %d\n", capabilities_names[i], err);
                        }
		/* Raise only caps mentioned in 'caps' variable and drop all other caps except CAP_SETPCAP. Because if we drop this,
		 * prctl operation will fail and we cannot complete this for loop. So keep CAP_SETPCAP until we finish this for loop.
		 */
                } else if (i != CAP_SETPCAP) {
                        if (prctl(PR_CAPBSET_DROP, i, 0, 0, 0) < 0) {
				printf("Error to apply PR_CAPBSET_DROP for %s\n", capabilities_names[i]);
                        }
                } else {
			/* We keep a flag 'flg' set if we found CAP_SETPCAP not dropped. So that we can drop this later */
                        flg = 1;
                }
        }

	/* If flg is set, then drop CAP_SETPCAP also finally. */
        if (flg) {
                if (prctl(PR_CAPBSET_DROP, CAP_SETPCAP, 0, 0, 0) < 0) {
			printf("Error to apply PR_CAPBSET_DROP for %s\n", capabilities_names[CAP_SETPCAP]);
                }
        }

//	caps_read_all();

	/* Now execute the program with execve. This operation should inherit only requested caps. */
	printf("Executing %s\n", argv[0]);
	execve(argv[0], argv, environ);
	perror("execve");
	
	return(0);
}
